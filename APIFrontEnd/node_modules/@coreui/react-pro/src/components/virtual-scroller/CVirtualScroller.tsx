import React, { forwardRef, HTMLAttributes, UIEvent, useEffect, useRef, useState } from 'react'
import PropTypes from 'prop-types'
import classNames from 'classnames'

import { useForkedRef } from '../../utils/hooks'

export interface CVirtualScrollerProps extends Omit<HTMLAttributes<HTMLDivElement>, 'onScroll'> {
  /**
   * A string of all className you want applied to the base component.
   */
  className?: string
  /**
   * Single item height.
   */
  itemHeight?: number | 'auto'
  /**
   * Number of items.
   */
  itemsNumber?: number
  /**
   * Event fires when the component has been scrolled.
   */
  onScroll?: (currentItemIndex: number) => void
  /**
   * Amount of visible items
   */
  visibleItems: number
}

export const CVirtualScroller = forwardRef<HTMLDivElement, CVirtualScrollerProps>(
  ({ children, className, itemHeight = 'auto', visibleItems, itemsNumber, onScroll }, ref) => {
    const virtualScrollRef = useRef<HTMLDivElement>(null)
    const virtualScrollContentRef = useRef<HTMLDivElement>(null)
    const forkedRef = useForkedRef(ref, virtualScrollRef)

    const [currentItemIndex, setCurrentItemIndex] = useState(0)
    const [_itemHeight, setItemHeight] = useState<number>(itemHeight === 'auto' ? 0 : itemHeight)
    const [_itemsNumber, setItemsNumber] = useState(itemsNumber || React.Children.count(children))
    const [viewportPadding, setViewportPadding] = useState(0)
    const [viewportHeight, setViewportHeight] = useState(
      visibleItems * _itemHeight + 2 * viewportPadding,
    )
    const [maxHeight, setMaxHeight] = useState(_itemsNumber * _itemHeight + 2 * viewportPadding)
    const [topPadding, setTopPadding] = useState(0)
    const [bottomPadding, setBottomPadding] = useState(0)

    const [contentHeight, setContentHeight] = useState(0)

    useEffect(() => {
      virtualScrollRef.current && virtualScrollRef.current.scrollTop

      virtualScrollRef.current &&
        setViewportPadding(parseFloat(getComputedStyle(virtualScrollRef.current).paddingTop))
    })

    useEffect(() => {
      setItemsNumber(itemsNumber || React.Children.count(children))
    }, [children, itemsNumber])

    useEffect(() => {
      setViewportHeight(visibleItems * _itemHeight + 2 * viewportPadding)
    }, [viewportPadding, visibleItems, _itemHeight])

    useEffect(() => {
      setMaxHeight(_itemsNumber * _itemHeight + 2 * viewportPadding)
      virtualScrollRef.current && virtualScrollRef.current.scrollTop
      setTopPadding(0)
    }, [_itemsNumber, _itemHeight])

    const handleScroll = (scrollTop: number) => {
      const _currentItemIndex = Math.min(
        Math.max(
          1 +
            Math.max(Math.floor(scrollTop / _itemHeight), 0) -
            Math.min(
              Math.floor(visibleItems / 2) - (Math.floor(visibleItems / 2) - currentItemIndex) - 1,
              Math.floor(visibleItems / 2),
            ),
          1,
        ),
        _itemsNumber - visibleItems + 1,
      )

      virtualScrollContentRef.current &&
        setContentHeight(virtualScrollContentRef.current.offsetHeight)
      setTopPadding(Math.max(_currentItemIndex * _itemHeight - _itemHeight, 0))
      setBottomPadding(Math.max(maxHeight - topPadding - contentHeight, 0))
      setCurrentItemIndex(_currentItemIndex)
      onScroll && onScroll(_currentItemIndex)
    }

    const _className = classNames('virtual-scroller', className)

    return (
      <div
        className={_className}
        onScroll={(event: UIEvent<HTMLDivElement>) =>
          handleScroll((event.target as HTMLDivElement).scrollTop)
        }
        ref={forkedRef}
        style={{
          height: maxHeight > viewportHeight ? viewportHeight : maxHeight,
          overflowY: 'auto',
        }}
      >
        <div style={{ height: topPadding }} />
        <div className="virtual-scroller-content" ref={virtualScrollContentRef}>
          {React.Children.map(children, (child, index) => {
            const _index = index + 1
            if (
              React.isValidElement(child) &&
              _index >= Math.max(currentItemIndex - Math.floor(visibleItems / 2), 0) &&
              _index <= currentItemIndex + visibleItems + Math.floor(visibleItems / 2)
            ) {
              return React.cloneElement(child as React.ReactElement<any>, {
                className: classNames(child.props.className, {
                  'virtual-scroller-item-preload':
                    _index > currentItemIndex + visibleItems || _index < currentItemIndex,
                }),
                key: index,
                ref: (node: HTMLElement) =>
                  itemHeight === 'auto' &&
                  node &&
                  node.offsetHeight &&
                  setItemHeight(
                    node.offsetHeight +
                      parseFloat(getComputedStyle(node).marginTop) +
                      parseFloat(getComputedStyle(node).marginBottom),
                  ),
              })
            }
            return
          })}
        </div>
        <div
          style={{
            height: bottomPadding,
          }}
        />
      </div>
    )
  },
)

CVirtualScroller.propTypes = {
  itemHeight: PropTypes.number,
  itemsNumber: PropTypes.number,
  onScroll: PropTypes.func,
  visibleItems: PropTypes.number.isRequired,
}

CVirtualScroller.displayName = 'CVirtualScroller'
